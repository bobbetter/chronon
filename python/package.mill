package build.python

import mill.*
import mill.pythonlib.*

// Python API module
object `package` extends PythonModule with RuffModule with PublishModule {

  /**
   * Detect the best Python executable to use.
   * Priority: 1) activated venv (VIRTUAL_ENV), 2) repo .venv, 3) system python3
   */
  private def detectPythonExecutable(baseDir: os.Path): String = {
    sys.env.get("VIRTUAL_ENV") match {
      case Some(venvPath) =>
        val venvPython = os.Path(venvPath) / "bin" / "python"
        if (os.exists(venvPython)) venvPython.toString
        else "python3"
      case None =>
        val repoVenvPython = baseDir / ".venv" / "bin" / "python"
        if (os.exists(repoVenvPython)) repoVenvPython.toString
        else "python3"
    }
  }

  // Override the Python interpreter used by Mill to create its venv
  override def hostPythonCommand: T[String] = Task {
    val pythonCmd = detectPythonExecutable(moduleDir / os.up)
    println(s"Using Python: $pythonCmd")
    pythonCmd
  }

  def pythonRequirementFiles = Task.Sources("requirements/base.txt")

  // TODO: doing this because we want the whl to have Requires-Dist metadata.
  def pythonDeps: T[Seq[String]] = Task {
    // Use the same file that pythonRequirementFiles references
    val reqFiles = pythonRequirementFiles()
    if (reqFiles.nonEmpty) {
      val reqFile = reqFiles.head.path
      if (os.exists(reqFile)) {
        os.read.lines(reqFile)
          .map(_.trim)
          .filter(line => line.nonEmpty && !line.startsWith("#"))
          .filter(!_.startsWith("-"))  // Skip pip flags like -e
          .toSeq
      } else {
        Seq.empty[String]
      }
    } else {
      Seq.empty[String]
    }
  }

  def mainScript = Task.Source("src/ai/chronon/repo/zipline.py")

  def publishMeta = PublishMeta(
    name = "zipline-ai",
    description = "CLI tool for the Zipline AI platform",
    requiresPython = ">= 3.11",
    license = License.`Apache-2.0`,
    authors = Seq(Developer("Zipline AI", "hello@zipline.ai")),
    urls = Map(
        "homepage" -> "https://zipline.ai",
        "documentation" -> "https://docs.zipline.ai",
        "github" -> "https://github.com/zipline-ai/chronon/",
    )
  )

  override def publishVersion = Task.Input {
    Task.env.getOrElse("CHRONON_VERSION", "2025.12.22")
  }

  def sources = super.sources() ++ generatedSources()

  // the mill PythonModule doesn't yet support entrypoints, so extend it manually
  def pyproject: T[String] = Task {
    super.pyproject() + """|
         |[project.scripts]
         |zipline = "ai.chronon.repo.zipline:zipline"
         |""".stripMargin
  }


  object test extends PythonTests, TestModule.Pytest, CoverageTests {
    def pythonRequirementFiles = Task.Sources(moduleDir / os.up / "requirements" / "base.txt")

    override def sources = Task.Sources(moduleDir)

    // Override forkEnv to set PYTHONPATH for test isolation
    override def forkEnv: T[Map[String, String]] = Task {

      val generatedPath = build.python.generatedSources().head.path.toString
      val sourcePath = (moduleDir / os.up / "src").toString
      // Note: samplePath removed from global PYTHONPATH to avoid conflicts with canary/
      super.forkEnv() ++ Map(
        "PYTHONPATH" -> s"$generatedPath:$sourcePath",
      )

    }

  }


  // Generate Python thrift files
  def generatedSources: T[Seq[PathRef]] = Task {
    val outputDir = Task.dest
    os.makeDir.all(outputDir)

    val sources = build.thrift.thriftSources()
    val thriftFiles = sources.flatMap(p => os.list(p.path)).filter(_.ext == "thrift")

    thriftFiles.foreach { thriftFile =>
      println(s"Generating Python thrift for: $thriftFile")
      os.proc("thrift", "--gen", "py", "-out", outputDir, thriftFile).call()
    }

    Seq(PathRef(outputDir))
  }

  // Build wheel and install normally
  def installWheel = Task {
    val wheelPath = wheel().path
    val pythonExec = detectPythonExecutable(moduleDir / os.up)
    println(s"Installing wheel from: $wheelPath using: $pythonExec")
    
    // Uninstall existing version first
    try {
      os.proc(pythonExec, "-m", "pip", "uninstall", "-y", "zipline-ai").call()
    } catch {
      case _: Exception => println("No existing zipline-ai package to uninstall")
    }
    
    // Install the built wheel
    os.proc(pythonExec, "-m", "pip", "install", wheelPath.toString).call()
    
    println(s"Wheel installed successfully from: $wheelPath")
  }

  // Install in editable mode with generated sources. Can mess ruffCheck import order (due to gen_thrift priority change)
  def installEditable() = Task.Command {
    // Generate sources in Task.dest as usual
    val generatedPaths = generatedSources()
    
    // Copy generated sources to src/
    val pythonDir = moduleDir
    val srcDir = pythonDir / "src"
    generatedPaths.foreach { pathRef =>
      val generatedDir = pathRef.path
      println(s"Generated dir: $generatedDir")
      if (os.exists(generatedDir)) {
        // Copy contents of the generated directory to src/
        os.list(generatedDir).foreach { item =>
          if (os.isDir(item)) {
            os.copy.over(item, srcDir / item.last, followLinks = true, replaceExisting = true, copyAttributes = false, createFolders = true)
          }
        }
        println(s"Copied generated sources from $generatedDir to $srcDir")
      }
    }
    
    // Use unified Python detection
    val pythonExec = detectPythonExecutable(moduleDir / os.up)
    println(s"Using python executable: $pythonExec")
    
    // Install in editable mode
    println(s"Working directory: $pythonDir")
    os.proc(pythonExec, "-m", "pip", "install", "-e", ".").call(cwd = pythonDir)
    println("Package installed in editable mode with generated sources")
  }
}
